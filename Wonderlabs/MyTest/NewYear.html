<!DOCTYPE html>
<html lang="en">

	<head>
		<title>Happy New Year</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				/*background-color: #000;*/
				background-color: red;

				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				height: 100%;
				text-align: center;
				z-index: 100;
				display: block;
			}
			
			#info a {
				color: #046;
				font-weight: bold;
			}
			
			#modelLeft{
				width: 128px;
				height: 128px;
				background-image: url(Image/arrow/left.png);
				background-color:transparent;
				border: transparent;				
				float:right;
				margin-right: 10%;
				margin-top: 50%;
			}
			
			#modelRight{
				width: 128px;
				height: 128px;
				background-image: url(Image/arrow/right.png);
				background-color:transparent;
				border: transparent;	
				margin-left: 5%;
				margin-top: 50%;
			}
			
			#animationButton1{
				width: 128px;
				height: 64px;
				background-image: url(Image/bainian.png);
			}
			
			#left{
				width: 128px;
				height: 128px;
				background-image: url(Image/arrow/left.png);
				background-color:transparent;
				border: transparent;	
				/*background-position: 10% 50%;*/
			}
			
			#right{
				width: 128px;
				height: 128px;
				background-image: url(Image/arrow/right.png);
				background-color:transparent;
				/*border: transparent;*/				
				/*background-position: 10% 50%;*/
			}
			/*button{
				
			}*/
		</style>
	</head>

	<body>
		<div id="info">
			<!--<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - FBXLoader<br /> Character and animation from-->
			<!--<a href="https://www.mixamo.com/" target="_blank" rel="noopener">Mixamo</a>-->
			</br>		
			<button id = "modelLeft", onclick="SwitchModel(0)"></button>
			<button id = "modelRight", onclick="SwitchModel(1)"></button>
			
			</br>
			<button id = "animationButton1", onclick="ClipAnimation(selectModelID,0)"></button>
			<button id = "animationButton1", onclick="ClipAnimation(selectModelID,1)"></button>
			<button id = "animationButton1", onclick="ClipAnimation(selectModelID,2)"></button>
			<button id = "animationButton1", onclick="ClipAnimation(selectModelID,3)"></button>	

		</div>

		<script src="js/three.js"></script>

		<script src="js/inflate.min.js"></script>
		<script src="js/FBXLoader.js"></script>

		<script src="js/OrbitControls.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/stats.min.js"></script>

		<script>
			if(!Detector.webgl) Detector.addGetWebGLMessage();

			var container, stats, controls;
			var camera, scene, renderer, light;

			//显示中的模型
			var activeModel;
			//用来记录模型的下标
			var index = 0;

			var clock = new THREE.Clock();

			//显示的模型的下标
			var selectModelID = -1;
			//之前被选中的模型的下标
			var lastModelID = -1;
			//模型数组
			var models = new Array();
			//所有模型的动画数组
			var mixers = new Array();

			var action;
			//是否播放动画
			var isAction = false;
			var loader = new THREE.FBXLoader();
			
			var parameters = {
				oceanSide: 500,
				size: 1.0,
				distortionScale: 3.7,
				alpha: 1.0
			};

			init();
			animate();

			//创建人类对象
//			function person(model, ID, animation) {
//				this.model = model;
//				this.ID = ID;
//				this.animation = animation;
//			}

			function init() {

				container = document.createElement('div');
				document.body.appendChild(container);

				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
				camera.position.set(100, 200, 400);

				controls = new THREE.OrbitControls(camera);
				controls.target.set(0, 100, 0);
				controls.update();

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xa0a0a0);
				light = new THREE.HemisphereLight(0xffffff, 0x444444);
				light.position.set(0, 200, 0);
				scene.add(light);

				light = new THREE.DirectionalLight(0xffffff);
				light.position.set(0, 200, 100);
				light.castShadow = true;
				light.shadow.camera.top = 180;
				light.shadow.camera.bottom = -100;
				light.shadow.camera.left = -120;
				light.shadow.camera.right = 120;
				scene.add(light);

				
			// skybox
			//setSkybox();
			var geometry = new THREE.SphereBufferGeometry(500, 500, 500);
				geometry.scale(-1, 1, 1);
				
				var material = new THREE.MeshBasicMaterial({
					map: new THREE.TextureLoader().load('Image/star.jpg')
					//color: 0xff0000
				});
				mesh = new THREE.Mesh(geometry, material);
				mesh.name = "skybox";
				scene.add(mesh);
			
				// ground
//				var mesh = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshPhongMaterial({
//					color: 0x999999,
//					depthWrite: false
//				}));
//				mesh.rotation.x = -Math.PI / 2;
//				mesh.receiveShadow = true;
//				scene.add(mesh);

				//添加网格
				//				var grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
				//				grid.material.opacity = 0.2;
				//				grid.material.transparent = true;
				//				scene.add( grid );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMap.enabled = true;
				container.appendChild(renderer.domElement);

				window.addEventListener('resize', onWindowResize, false);

				// stats
				//性能插件stats实现性能监听实例详解
				//stats = new Stats();
				//container.appendChild(stats.dom);

				// model
				//加载第一个模型
				Load('CUBE/cube.fbx');
				Load('maxiu/123.fbx');
				Load('maxiu/MM.fbx');
			}

			//天空球
			function setSkybox() {

				var cubeTextureLoader = new THREE.CubeTextureLoader();
				//cubeTextureLoader.setPath( 'Image/skyboxsun25deg/' );
				cubeTextureLoader.setPath( 'Image/new/' );


				cubeMap = cubeTextureLoader.load( [
					'px.jpg', 'nx.jpg',
					'py.jpg', 'ny.jpg',
					'pz.jpg', 'nz.jpg',
				] );

				var cubeShader = THREE.ShaderLib[ 'cube' ];
				cubeShader.uniforms[ 'tCube' ].value = cubeMap;

				var skyBoxMaterial = new THREE.ShaderMaterial( {
					fragmentShader: cubeShader.fragmentShader,
					vertexShader: cubeShader.vertexShader,
					uniforms: cubeShader.uniforms,
					side: THREE.BackSide
				} );

				var skyBoxGeometry = new THREE.BoxBufferGeometry(
					parameters.oceanSide * 5 + 100,
					parameters.oceanSide * 5 + 100,
					parameters.oceanSide * 5 + 100 );

				var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );

				scene.add( skyBox );

			}

			//FBX加载
			function Load(path) {
				loader.load(path, FBXModel);
			}

			//加载场景模型
			function LoadSceneModel(path){
				loader.load(path, FBXSceneModel);
			}
			
			//加载场景模型
			function FBXSceneModel(object){
				scene.add(object);
			}
			
			//加载FBXModel
			function FBXModel(object) {
				//index表示加载的模型
				models[index] = object;
				//隐藏加载的模型
				models[index].visible = false;
				scene.add(object);
				AddAnimation(object, index);
				index++;
			}

			//添加动画数据,model:生成的模型 animationNum:动画列表的下标
			function AddAnimation(model, animationNum) {
				//读取模型中的动画
				model.mixer = new THREE.AnimationMixer(model);
				//定义混合动画数组
				mixers[animationNum] = new Array();
				//将混合动画从尾部添加动画
				mixers[animationNum].push(model.mixer);
				//定义动画
				//action= model.mixer.clipAction(model.animations[0]);
				//
				model.traverse(function(child) {

					if(child.isMesh) {

						child.castShadow = true;
						child.receiveShadow = true;
					}

				});
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			//替换模型
			function SwitchModel(modelNum) {
				//如果有模型显示中，先隐藏当前的模型		
				if(activeModel != null) {
					activeModel.visible = false;
				}
				//显示当前选中的模型
				models[modelNum].visible = true;
				//显示模型为当先选中的模型
				activeModel = models[modelNum];
				//选中模型的下标为当前模型的下标
				selectModelID = modelNum;
				//console.log("modelNum="+modelNum);
			}

			//切换选中模型的动画
			function ClipAnimation(modelID, i) {
				//假设已经有动画在播放，停止该动画
				if(action != null) {
					action.stop();
				}
				//选择当前需要播放的动画
				action = models[modelID].mixer.clipAction(models[modelID].animations[i]);
				//播放选择的动画
				action.play();
				//正在播放动画
				isAction = true;
			}

			function animate() {

				requestAnimationFrame(animate);
				//当有动画需要被播放，就逐帧播放该动画
				if(action != null) {
					if(mixers[selectModelID].length > 0) {
						for(var i = 0; i < mixers[selectModelID].length; i++) {
							models[selectModelID].mixer.update(clock.getDelta());
						}

					}
				}
				renderer.render(scene, camera);

				//stats.update();

			}
		</script>

	</body>

</html>